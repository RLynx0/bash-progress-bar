#!/usr/bin/env bash

DEFAULT__DEMO_TOTAL=250
DEFAULT__BAR='minimal'
DEFAULT__EMPTY_STR=' '
DEFAULT__COLORS='none'
DEFAULT__BAR_START='['
DEFAULT__BAR_END='] '
DEFAULT__STATUS_FMT='{perc}%'
DEFAULT__WIDTH=100
DEFAULT__MAX_WIDTH=''
DEFAULT__INTERVAL=1

BAR="${BAR:-"$DEFAULT__BAR"}"
EMPTY_STR="${EMPTY_STR:-"$DEFAULT__EMPTY_STR"}"
COLORS="${COLORS:-"$DEFAULT__COLORS"}"
BAR_START="${BAR_START:-"$DEFAULT__BAR_START"}"
BAR_END="${BAR_END:-"$DEFAULT__BAR_END"}"
STATUS_FMT="${STATUS_FMT:-"$DEFAULT__STATUS_FMT"}"
WIDTH="${WIDTH:-"$DEFAULT__WIDTH"}"
MAX_WIDTH="${MAX_WIDTH:-"$DEFAULT__MAX_WIDTH"}"
INTERVAL="${INTERVAL:-"$DEFAULT__INTERVAL"}"
SIZE_STRICT=''

CALLNAME="${0##*/}"
BARCHARS=('#')
GRADIENT=()
ARGS=()
DEMO=''

declare pb_last_cols
declare pb_last_color
declare pb_last_index
declare -a pb_last_totals
declare -a pb_last_bar_percs
declare -a pb_last_status_texts
function pb_reset-vars {
  pb_last_cols=''
  pb_last_color=''
  pb_last_index=''
  pb_last_totals=()
  pb_last_bar_percs=()
  pb_last_status_texts=()
}

function hexlerp {
  local a="$1"; local b="$2"; local step="$3"; local steps="$4"
  echo "$((16#${a} + (16#${b} - 16#${a}) * step / steps))"
}

function pb_get-simple-color {
  local col_index="$((16#${1}))"
  [ "$col_index" -lt 8 ] \
  && col_index="$((col_index + 30))" \
  || col_index="$((col_index + 90 - 8))"
  local color="\033[${col_index}m"
  [ "$color" == "$pb_last_color" ] && echo '' && return
  pb_last_color="$color"
  echo "$color"
}

function pb_get-color {
  local cur="$(($1 - 1))"
  local last="$(($2 - 1))"
  local n_colors="${#GRADIENT[@]}"
  [ "$n_colors" -eq 0 ] && echo '' && return

  local grad_full_i="$((cur * (n_colors - 1)))"
  local lerp_val="$((grad_full_i % last))"
  local i="$(((grad_full_i / last) % n_colors))"
  local j="$(((i + 1) % n_colors))"

  [[ "${GRADIENT["$i"]}" =~ ^[a-FA-F0-9]$ ]] \
  && pb_get-simple-color "${GRADIENT["$i"]}" \
  && return

  local c0; local c1
  local r; local g; local b
  if [ "$lerp_val" -eq 0 ] \
  || [[ "${GRADIENT["$j"]}" =~ ^[a-FA-F0-9]$ ]]; then
    c0="${GRADIENT["$i"]}"
    r="$((16#${c0:0:2}))"
    g="$((16#${c0:2:2}))"
    b="$((16#${c0:4:2}))"
  else
    c0="${GRADIENT["$i"]}"
    c1="${GRADIENT["$j"]}"
    r="$(hexlerp "${c0:0:2}" "${c1:0:2}" "$lerp_val" "$last")"
    g="$(hexlerp "${c0:2:2}" "${c1:2:2}" "$lerp_val" "$last")"
    b="$(hexlerp "${c0:4:2}" "${c1:4:2}" "$lerp_val" "$last")"
  fi

  local color="\033[38;2;${r};${g};${b}m"
  [ "$color" == "$pb_last_color" ] && echo '' && return
  pb_last_color="$color"
  echo "$color"
}

function pb_reset-color {
  local color="\033[0m"
  [ "$color" == "$pb_last_color" ] && echo '' && return
  pb_last_color="$color"
  echo "$color"
}

function pb_pad {
  local text="$1"
  local pad_str="$2"
  local pad_side="$3"
  local pad_len="$(($4 - ${#text}))"

  local padding_l; local padding_r
  for ((i = 0; i < pad_len / 2; i++)); do
    padding_l+="${pad_str:i % ${#pad_str}:1}"
  done
  for ((; i < pad_len; i++)); do
    padding_r+="${pad_str:i % ${#pad_str}:1}"
  done

  case "$pad_side" in
    '>'|'') echo "${padding_l}${padding_r}${text}" ;;
    '<')    echo "${text}${padding_l}${padding_r}" ;;
    '^')    echo "${padding_l}${text}${padding_r}" ;;
  esac
}

function pb_get-status-text {
  local done="$1"
  local todo="$2"
  local perc="$((done * 100 / todo))"
  local text="$STATUS_FMT"

  while [[ "$text" =~ \{([a-zA-Z_][a-zA-Z0-9_]*|\"[^\{\"]+\")(:(([^\}]*)([<^>]))?([0-9]+))?\} ]]; do
    local st_match="${BASH_REMATCH[0]}"
    local st_expr="${BASH_REMATCH[1]}"
    local st_pad_len="${BASH_REMATCH[6]:-0}"
    local st_pad_str="${BASH_REMATCH[4]:-" "}"
    local st_pad_side="${BASH_REMATCH[5]}"

    local st_resolved=''
    [[ "$st_expr" =~ ^\"(.+)\"$ ]] \
    && st_resolved="${BASH_REMATCH[1]}" \
    || st_resolved="${!st_expr}"

    text="${text/"$st_match"/"$(pb_pad "$st_resolved" "$st_pad_str" "$st_pad_side" "$st_pad_len")"}"
  done

  echo "$text"
}

# Returns ANSII code to move cursor left or right
function pb_move-horizontal {
  m="$1"
  if   [ "$m" -eq 0 ]; then echo ''
  elif [ "$m" -gt 0 ]; then echo "\033[${m}C"
  elif [ "$m" -lt 0 ]; then echo "\033[$((0 - m))D"
  fi
}

# Returns ANSII code to move cursor up or down
function pb_move-vertical {
  m="$1"
  if   [ "$m" -eq 0 ]; then echo ''
  elif [ "$m" -gt 0 ]; then echo "\033[${m}B"
  elif [ "$m" -lt 0 ]; then echo "\033[$((0 - m))A"
  fi
}

function pb_print-bar {
  local index="$1"
  local done="$2"
  local todo="$3"
  local cols="$4"

  # Sanity checks
  [ "$todo" -le 0 ] && todo=1
  [ "$done" -lt 0 ] && done=0
  [ "$done" -gt "$todo" ] && done="$todo"

  # Get terminal space and reserved area length
  local status_text="$(pb_get-status-text "$done" "$todo")"
  local final_status="$(pb_get-status-text "$todo" "$todo")"
  local reserved="$((${#BAR_START} + ${#BAR_END} + ${#final_status} + 1))"
  cols="${COLUMNS:-$(tput cols)}" # TEMP

  # Calculcate bar_width from cols, width-perc and max-width
  local bar_width="$cols"
  [ "$WIDTH" -le 100 ] && bar_width=$((bar_width * WIDTH / 100))
  [ -n "$MAX_WIDTH" ] && [ "$bar_width" -gt "$MAX_WIDTH" ] && bar_width="$MAX_WIDTH"
  [ -n "$SIZE_STRICT" ] && bar_width="$((bar_width - reserved))"
  [ "$((bar_width + reserved))" -gt "$cols" ] && bar_width="$((cols - reserved))"
  [ "$bar_width" -lt 0 ] && bar_width=0

  # Last status_text and bar_perc
  local last_status_text="${pb_last_status_texts["$index"]}"
  local last_bar_perc="${pb_last_bar_percs["$index"]}"

  # Pad out status_text to overwrite longer old one
  while [ "${#status_text}" -lt "${#final_status}" ]; do
    status_text+=" "
  done

  # Variables related to the actual bar
  local bfactor="${#BARCHARS[@]}"
  local full_bar="$((bar_width * bfactor))"
  local bar_perc="$((done * full_bar / todo))"
  local sub_i="$((bar_perc % bfactor))"

  # Return early if nothing changed
  [ "$cols" == "$pb_last_cols" ] \
  && [ "$bar_perc" == "$last_bar_perc" ] \
  && [ "$status_text" == "$last_status_text" ] \
  && return
  
  # Work variables
  local i; local a; local b; local c
  local ma="-${#final_status}"
  local mc=0
  local color

  # Choose draw mode
  local draw_to_bar=''
  local full_redraw=''
  local draw_empty_to=0
  if [ "${pb_last_totals["$index"]}" != "$todo" ]; then
    # Terminal window changed -> Redraw everything
    pb_last_totals["$index"]="$todo"
    draw_empty_to="$bar_width"
    pb_last_cols="$cols"
    last_bar_perc=0
    draw_to_bar=1
    full_redraw=1
  elif [ "$last_bar_perc" -lt "$bar_perc" ]; then
    # Only progress changed -> Add new bar-characters
    # Calculate cursor offset to overwrite only the changed section
    ma="$((ma - ${#BAR_END} - bar_width + (last_bar_perc / bfactor)))"
    mc="$((mc + (full_bar - bar_perc) / bfactor + ${#BAR_END}))"
    draw_to_bar=1
  elif [ "$last_bar_perc" -gt "$bar_perc" ]; then
    # Redraw bar section cleanly
    ma="$((ma - ${#BAR_END} - bar_width + (bar_perc / bfactor)))"
    draw_empty_to="$(((last_bar_perc + bfactor - 1) / bfactor))"
    mc="$((mc + bar_width - draw_empty_to + ${#BAR_END}))"
    last_bar_perc="$bar_perc"
    draw_to_bar=1
  fi

  if [ -n "$full_redraw" ]; then
    # Full redraw: Clear the line and draw all elements
    a="\r\033[K${BAR_START}"
    c="${BAR_END}"
  else
    # Incremental update: Just move cursor to the right places
    a="$(pb_move-horizontal "$ma")"
    c="$(pb_move-horizontal "$mc")"
  fi

  if [ -n "$draw_to_bar" ]; then
    # Continue drawing bar from last progress point
    i="$((last_bar_perc / bfactor))"
    for ((; i < bar_perc / bfactor; i++)); do
      color="$(pb_get-color "$(((i + 1) * bfactor))" "$full_bar")"
      b+="${color}${BARCHARS[-1]}"
    done

    # Add sub-character for fractional progress
    if [ "$sub_i" -gt 0 ]; then
      color="$(pb_get-color "$bar_perc" "$full_bar")"
      b+="${color}${BARCHARS["$((sub_i - 1))"]}"
      i="$((i + 1))"
    fi

    # Reset color
    b+="$(pb_reset-color)"

    # Pad with empty characters
    for ((; i < draw_empty_to; i++)); do
      b+="${EMPTY_STR:i % ${#EMPTY_STR}:1}"
    done
  fi

  # Save current state for next update
  pb_last_index="$index"
  pb_last_bar_percs["$index"]="$bar_perc"
  pb_last_status_texts["$index"]="$status_text"

  # Draw the bar and status
  echo -ne "${a}${b}${c}${status_text}"
}

function pb_animate-progress-bars {
  local -a totals=("$1")
  local -a values=()
  local bar_index=0
  local i; local n
  local nb=1

  while read -s xs; do
    xs="${xs// /}"
    xs="${xs//;/ }"
    for x in $xs; do
      [[ "$x" =~ ^(([0-9]+):)?([+-]?[0-9]+)(/([1-9][0-9]*))?$ ]] || continue
      i="${BASH_REMATCH[2]:-"$bar_index"}"
      totals["$i"]="${BASH_REMATCH[5]:-"$1"}"
      values["$i"]="${values["$i"]:-0}"
      n="${BASH_REMATCH[3]}"

      if [[ "$n" =~ \+ ]]; then
        n="$((values[i] + ${n#\+}))"
      elif [[ "$n" =~ - ]]; then
        n="$((values[i] - ${n#-}))"
      fi

      # Skip depending on interval
      [ "$((n % INTERVAL))" -eq 0 ] \
      || [ "$n" -ge "${totals["$i"]}" ] \
      || continue

      local s=''
      while [ "$nb" -le "$i" ]; do
        nb=$((nb + 1))
        bar_index=$((bar_index + 1))
        s+="\n"
      done

      echo -en "$(pb_move-vertical $((i - bar_index)))$s"
      pb_print-bar "$i" "$n" "${totals["$i"]}"

      values["$i"]="$n"
      bar_index="$i"
    done
  done

  for ((i = bar_index; i < nb; i++)); do echo; done
}

function pb_list {
  local mode="$1"

  if [ "$mode" == 'a' ] || [ "$mode" == 'p' ]; then
    echo 'Available PRESETS (--preset):'
    for demo_preset in "${PRESET_NAMES[@]}"; do
      echo -e "  $demo_preset"
    done
  fi

  [ "$mode" == 'a' ] && echo -e '\n'
  if [ "$mode" == 'a' ] || [ "$mode" == 'b' ]; then
    echo 'Available BAR-PRESETS (--bar):'
    for demo_bar in "${BAR_PRESET_NAMES[@]}"; do
      resolve_bar "$demo_bar"
      echo -n "  $(pb_pad "$demo_bar" ' ' '<' 12)"
      echo "--bar '$(printf "%s" "${BARCHARS[@]}")'"
    done
  fi

  [ "$mode" == 'a' ] && echo -e '\n'
  if [ "$mode" == 'a' ] || [ "$mode" == 'c' ]; then
    echo 'Available COLOR-PRESETS (--colors):'
    for demo_colors in "${COLOR_PRESET_NAMES[@]}"; do
      resolve_colors "$demo_colors"
      echo -n "  $(pb_pad "$demo_colors" ' ' '<' 12)"
      [ "${#GRADIENT}" -eq 0 ] && echo \
      || echo "--colors '$(printf "#%s;" "${GRADIENT[@]}")'"
    done
  fi
}

function pb_demo {
  total="$1"
  stty -echo -icanon
  for ((n = 0; n <= total; n++)); do echo "$n"
  done | COLUMNS='' pb_animate-progress-bars "$total"
  stty sane
}

function pb_show-off {
  local mode="$1"
  local total="$2"
  
  if [ "$mode" == 'a' ] || [ "$mode" == 'p' ]; then
    echo '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '‚ïë Showing off PRESETS ‚ïë'
    echo '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    for demo_preset in "${PRESET_NAMES[@]}"; do
      resolve_preset "$demo_preset"
      echo -e "\n=>> Option: --preset '$demo_preset'"
      pb_reset-vars; pb_demo "$total"
    done
  fi

  [ "$mode" == 'a' ] && echo -e '\n'
  if [ "$mode" == 'a' ] || [ "$mode" == 'b' ]; then
    resolve_preset 'bare'
    STATUS_FMT='{done}/{todo}'
    BAR_END=' '; EMPTY_STR='-'
    echo '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '‚ïë Showing off BAR-PRESETS ‚ïë'
    echo '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    for demo_bar in "${BAR_PRESET_NAMES[@]}"; do
      resolve_bar "$demo_bar"
      echo -e "\n=>> Option: --bar '$demo_bar'"
      echo "==> Equals: --bar '$(printf "%s" "${BARCHARS[@]}")'"
      pb_reset-vars; pb_demo "$total"
    done
  fi

  [ "$mode" == 'a' ] && echo -e '\n'
  if [ "$mode" == 'a' ] || [ "$mode" == 'c' ]; then
    resolve_preset 'bare'
    resolve_bar 'smooth'
    STATUS_FMT='{done}/{todo}'
    BAR_END=' '; EMPTY_STR='-'
    echo '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'
    echo '‚ïë Showing off COLOR-PRESETS ‚ïë'
    echo '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'
    for demo_color in "${COLOR_PRESET_NAMES[@]}"; do
      resolve_colors "$demo_color"
      echo -e "\n=>> Option: --colors '$demo_color'"
      [ "${#GRADIENT[@]}" -gt 0 ] \
      && echo "==> Equals: --colors '$(printf "#%s;" "${GRADIENT[@]}")'"
      pb_reset-vars; pb_demo "$total"
    done
  fi
}

function print_short_help {
  echo "Usage: $CALLNAME [OPTIONS] TOTAL
       $CALLNAME [OPTIONS] --list [SET]
       $CALLNAME [OPTIONS] --demo [TOTAL]
       $CALLNAME [OPTIONS] --show-off [SET] [TOTAL]

Arguments:
  TOTAL   Total count for the progress bar (non-negative integer).
          Required unless --help, --list, --demo or --show-off is given.
          Defaults to '$DEFAULT__DEMO_TOTAL' for --demo and --show-off.

Options:
  -p, --preset NAME       Apply a style preset.
  -c, --colors LIST       Gradient of rgb or 4-bit colors or preset name.    Default: '$DEFAULT__COLORS'
  -b, --bar NAME          Characters used to fill the bar or preset name.    Default: '$DEFAULT__BAR'
  -E, --empty-str STR     Pattern used to pad empty space in the bar.        Default: '$DEFAULT__EMPTY_STR'
  -s, --bar-start STR     String shown before the bar.                       Default: '$DEFAULT__BAR_START'
  -e, --bar-end STR       String shown after the bar.                        Default: '$DEFAULT__BAR_END'
  -f, --status-fmt STR    Format string for status.                          Default: '$DEFAULT__STATUS_FMT'
  -i, --interval N        Update only if input is divisible by N.            Default: '$DEFAULT__INTERVAL'
  -w, --width PERCENT     Set bar width as percentage of terminal width.     Default: '$DEFAULT__WIDTH'
  -W, --max-width COLS    Maximum bar width in columns.                      Default: '$DEFAULT__MAX_WIDTH'
  -S, --size-strict       Prevent overflowing width constraints.
  --help                  Show detailed help message and exit.
  -?, -h                  Show short help message and exit.

  --demo                  Run a demo progress bar with the current settings.
  -l, --list [SET]        List available presets for 'preset', 'bar', 'colors' or 'all'.
  --show-off [SET]        Preview available presets for 'preset', 'bar', 'colors' or 'all'."
}

function print_long_help {
  echo -e "A highly customizable, pure bash, multi-bar progress indicator for shell scripts.\n"
  print_short_help
  echo "
Examples:
  $CALLNAME -p rainbow 50
  $CALLNAME --colors '#FF0000;#00FF00;#0000FF' 75
  $CALLNAME --bar '.*|' --colors '1,2,4,F' --width 40 --demo
  $CALLNAME --demo -p bare -c matrix -b 0123456789 -W 10
  $CALLNAME --demo -b 'CCCCccccccccCCCC ' -E ' o ' -c yellow -w 25 2500
  $CALLNAME --show-off -w 50

Input and multi-bar usage:
  The script updates progress-bars according to input through stdin.
  It supports updating multiple bars at once.
  Input lines can look like this:

    N        Set progress of the current bar to N.
    N/M      Set progress of the current bar to N out of M.
    I:N      Update bar with index I to N.
    I:N/M    Update bar I to N out of M.
    I:+D     Increment bar I by D.
    I:-D     Decrement bar I by D.

  Example:
    printf '%s\n' '0:20' '1:60/200' '0:+5' '1:+10' | $CALLNAME 100

  This will print two bars, then increment bar 0 by 5 and bar 1 by 10.
  TOTAL=100 is only used for bar 0, since the second line specifies a total.

Notes:
  - Bars can only be updated while they are visible in the terminal viewport.
  - Use --demo or --show-off to preview different bar styles.

Status format:
  The status text shown next to the bar is defined by --status-fmt.
  It supports variable substitution and optional padding/alignment.

  Variables:
    {done}    Number of completed steps.
    {todo}    Total number of steps.
    {perc}    Percentage (integer).

  You can also insert sub-strings with {"..."}.
  These can include nested variables.

  Padding and alignment:
    {EXPR:N}, {EXPR:>N}    Right-align EXPR in width N.
    {EXPR:<N}              Left-align EXPR in width N.
    {EXPR:^N}              Center-align EXPR in width N.
    {EXPR:PAD>N}           Use PAD as padding instead of spaces.

  Examples:
    $CALLNAME --demo --status-fmt 'static status'
    $CALLNAME --demo -f '{done}/{todo} ({perc}%)'
    $CALLNAME --demo -f '{"{done}/{todo}":^9} ({perc:3}%)'"
}

function assert_arg {
  if [ -z "$2" ]; then
    echo "$1 requires an argument" >&2
    echo "Pass the --help flag for usage" >&2
    exit 1
  fi
}

function assert_num {
  assert_arg "$1" "$2"
  if ! [[ "$2" =~ ^[0-9]+$ ]]; then
    echo "Invalid argument for $1: '$2'" >&2
    echo "Must be a non-negative integer" >&2
    echo "Pass the --help flag for usage" >&2
    exit 1
  fi
}

COLOR_PRESET_NAMES=(
  'none'

  # Simple
  'red'         'yellow'       'green'
  'cyan'        'blue'         'magenta'
  'white'       'black'
  'light-red'   'light-yellow' 'light-green'
  'light-cyan'  'light-blue'   'light-magenta'
  'light-white' 'light-black'

  # Gradients
  'cool'   'galaxy' 'frost'  'ocean'
  'matrix' 'forest' 'health' 'fire'
  'sunset' 'candy'  'pride'
)
function resolve_colors {
  local colors="$1"
  local parsed

  if [[ "$colors" =~ ^(([a-fA-F0-9]|#?[a-fA-F0-9]{6})( *[;, ] *|$))*$ ]]; then
    parsed="${colors//[,;#]/ }"
  else
    case "$colors" in
      'none') parsed='' ;;

      'black')   parsed='0' ;;
      'red')     parsed='1' ;;
      'green')   parsed='2' ;;
      'yellow')  parsed='3' ;;
      'blue')    parsed='4' ;;
      'magenta') parsed='5' ;;
      'cyan')    parsed='6' ;;
      'white')   parsed='7' ;;

      'light-black')   parsed='8' ;;
      'light-red')     parsed='9' ;;
      'light-green')   parsed='A' ;;
      'light-yellow')  parsed='B' ;;
      'light-blue')    parsed='C' ;;
      'light-magenta') parsed='D' ;;
      'light-cyan')    parsed='E' ;;
      'light-white')   parsed='F' ;;

      'cool')   parsed='60C0C0 C080D8'                             ;;
      'galaxy') parsed='226088 4B2BA2 FF44FF'                      ;;
      'frost')  parsed='2288AA 00FFFF AFEEEE'                      ;;
      'ocean')  parsed='0066FF 00CCCC 00FF99'                      ;;
      'matrix') parsed='003300 00CC00 66FF66'                      ;;
      'forest') parsed='228B22 6B8E23 ADFF2F'                      ;;
      'health') parsed='FF0000 FFFF00 00FF00'                      ;;
      'fire')   parsed='FF4500 FF8C00 FFD722'                      ;;
      'sunset') parsed='FF4500 FF6347 FF1493'                      ;;
      'candy')  parsed='FF69B4 FFB6C1 FFD1DC'                      ;;
      'pride')  parsed='CC2222 CCCC22 22CC22 22CCCC 2222CC CC22CC' ;;

      *)
        {
          echo "Invalid colors: '$colors'"
          echo "Use a list of hex rgb colors, e.g. '#60C0C0, #C080D8'"
          echo "4-bit colors are supported by using single hex digits, e.g '1, A, C'"
          echo "Alternatively, use one of these predefined gradients:"
          for name in "${COLOR_PRESET_NAMES[@]}"; do
            echo "- '$name'"
          done
        } >&2
        exit 1
        ;;
    esac
  fi

  GRADIENT=()
  for color in $parsed; do
    GRADIENT+=($color)
  done
}

BAR_PRESET_NAMES=(
  'minimal'
  'blocky'
  'pipes'
  'dots'
  'fade'
  'paint'
  'pixel'
  'ramp'
  'smooth'
)
function resolve_bar {
  local bar="$1"
  case "$bar" in
    'minimal') BARCHARS=('#')                             ;;
    'blocky')  BARCHARS=('>' '%' '#')                     ;;
    'pipes')   BARCHARS=('.' ':' '!' '|')                 ;;
    'dots')    BARCHARS=('¬∑' '‚Ä¢' '‚óè')                     ;;
    'fade')    BARCHARS=('‚ñë' '‚ñí' '‚ñì' '‚ñà')                 ;;
    'paint')   BARCHARS=('ü¨Ä' 'ü¨Ñ' '‚ñå' 'ü¨ï' 'ü¨ù' '‚ñà')         ;;
    'pixel')   BARCHARS=('‚ññ' '‚ñò' '‚ñù' '‚ñó' '‚ñû' '‚ñö' '‚ñà')     ;;
    'ramp')    BARCHARS=('‚ñÅ' '‚ñÇ' '‚ñÉ' '‚ñÑ' '‚ñÖ' '‚ñÜ' '‚ñá' '‚ñà') ;;
    'smooth')  BARCHARS=('‚ñè' '‚ñé' '‚ñç' '‚ñå' '‚ñã' '‚ñä' '‚ñâ' '‚ñà') ;;
    *)
      BARCHARS=()
      for ((i = 0; i < ${#bar}; i++)); do
        BARCHARS+=("${bar:i:1}");
      done
      ;;
  esac
}

PRESET_NAMES=(
  'bare'
  'simple'
  'slick'
  'flame'
  'wave'
  'hacker'
  'rainbow'
)
function resolve_preset {
  case "$1" in
    '') ;;
    'bare')
      resolve_colors 'none';
      resolve_bar 'minimal';
      EMPTY_STR=' ';
      BAR_START='';
      BAR_END='';
      STATUS_FMT=''
      ;;
    'simple')
      resolve_colors 'none';
      resolve_bar 'minimal';
      EMPTY_STR=' ';
      BAR_START='[';
      BAR_END='] ';
      STATUS_FMT='{perc}%'
      ;;
    'slick')
      resolve_colors 'cool';
      resolve_bar 'blocky';
      EMPTY_STR='- ';
      BAR_START='[';
      BAR_END='] ';
      STATUS_FMT='{done}/{todo}'
      ;;
    'flame')
      resolve_colors 'fire';
      resolve_bar 'pipes';
      EMPTY_STR='.';
      BAR_START='{';
      BAR_END='} ';
      STATUS_FMT='{perc}!';
      ;;
    'wave')
      resolve_colors 'ocean';
      resolve_bar 'ramp';
      EMPTY_STR=' ';
      BAR_START='üÆá';
      BAR_END='‚ñè ';
      STATUS_FMT='{done}/{todo}';
      ;;
    'hacker')
      resolve_colors 'matrix';
      resolve_bar 'fade';
      EMPTY_STR=' ';
      BAR_START='‚ñë';
      BAR_END='‚ñë ';
      STATUS_FMT='PROGRESS {perc:0>3}%';
      ;;
    'rainbow')
      resolve_colors 'pride';
      resolve_bar 'smooth';
      EMPTY_STR='-';
      BAR_START='(:üÆá';
      BAR_END='‚ñè:) ';
      STATUS_FMT='{"{done}/{todo}":^9} ({perc:3}%)'
      ;;
    *)
      {
        echo "Unknown preset: '$1'"
        echo "Available presets are:"
        for name in "${PRESET_NAMES[@]}"; do
          echo "- '$name'"
        done
      } >&2
      exit 1
      ;;
  esac
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    '-p'|'--preset')     assert_arg "$1" "$2"; resolve_preset "$2"; shift 2 ;;
    '-c'|'--colors')     assert_arg "$1" "$2"; resolve_colors "$2"; shift 2 ;;
    '-b'|'--bar')        assert_arg "$1" "$2"; resolve_bar "$2";    shift 2 ;;
    '-E'|'--empty_str')  assert_arg "$1" "$2"; EMPTY_STR="$2";      shift 2 ;;
    '-s'|'--bar-start')  assert_arg "$1" "$2"; BAR_START="$2";      shift 2 ;;
    '-e'|'--bar-end')    assert_arg "$1" "$2"; BAR_END="$2";        shift 2 ;;
    '-f'|'--status-fmt') assert_arg "$1" "$2"; STATUS_FMT="$2";     shift 2 ;;
    '-i'|'--interval')   assert_num "$1" "$2"; INTERVAL="$2";       shift 2 ;;
    '-w'|'--width')      assert_num "$1" "$2"; WIDTH="$2";          shift 2 ;;
    '-W'|'--max-width')  assert_num "$1" "$2"; MAX_WIDTH="$2";      shift 2 ;;

    '-S'|'--size-strict') SIZE_STRICT='1'; shift 1 ;;
    '-l'|'--list')
      case "$2" in
        'bar'|'b')    pb_list 'b'; exit 0 ;;
        'colors'|'c') pb_list 'c'; exit 0 ;;
        'preset'|'p') pb_list 'p'; exit 0 ;;
        *)            pb_list 'a'; exit 0 ;;
      esac ;;
    '--show-off')
      case "$2" in
        'bar'|'b')    DEMO='b'; shift 2 ;;
        'colors'|'c') DEMO='c'; shift 2 ;;
        'preset'|'p') DEMO='p'; shift 2 ;;
        'all'|'a')    DEMO='a'; shift 2 ;;
        *)            DEMO='a'; shift 1 ;;
      esac ;;
    '--demo') DEMO="${DEMO:-1}"; shift 1 ;;
    '-?'|'-h') print_short_help; exit 0 ;;
    '--help') print_long_help; exit 0 ;;
    '--') shift 1; break ;;
    *)
      if [[ "$1" =~ ^-+.* ]]; then
        echo "Unknown option: '$1'" >&2
        echo "Pass the --help flag for usage" >&2
        exit 1
      else
        ARGS+=("$1")
        shift
      fi
      ;;
  esac
done

while [[ $# -gt 0 ]]; do ARGS+=($1); shift; done
if [ "${#ARGS[@]}" -gt 1 ]; then
  echo "Unexpected argument: '${ARGS[1]}'" >&2
  echo "Pass the --help flag for usage" >&2
  exit 1
fi

declare total="${ARGS[0]}"
[ -n "$DEMO" ] && total="${total:-"$DEFAULT__DEMO_TOTAL"}"
if [ -n "$total" ] && ! [[ "$total" =~ ^[0-9]+$ ]]; then
  echo "Invalid argument: '$total'" >&2
  echo "TOTAL must be a non-negative integer" >&2
  echo "Pass the --help flag for usage" >&2
  exit 1
fi

if   [ "$DEMO" == '1' ]; then pb_demo "$total"
elif [ -n "$DEMO"     ]; then pb_show-off "$DEMO" "$total"
elif [ -n "$total"    ]; then pb_animate-progress-bars "$total"
else
  echo "Usage: $CALLNAME [OPTIONS] TOTAL" >&2
  echo "Pass the --help flag for details" >&2
  exit 1
fi
